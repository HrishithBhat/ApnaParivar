const express = require('express');
const { authenticateToken, requireFamilyAdmin, requireFamilyAccess, requireActiveSubscription } = require('../middleware/permissions');
const { Family, User, FamilyMember } = require('../models');

const router = express.Router();

// @route   POST /api/families
// @desc    Create a new family tree (one per user)
// @access  Private
router.post('/', authenticateToken, async (req, res) => {
  try {
    const { familyName, description } = req.body;

    if (!familyName) {
      return res.status(400).json({
        success: false,
        message: 'Family name is required'
      });
    }

    // Check if user already has a family
    if (req.user.primaryFamily && req.user.primaryFamily.familyId) {
      return res.status(400).json({
        success: false,
        message: 'You already have a family tree. Each user can only create one family.'
      });
    }

    // Create new family (familyId will be auto-generated by pre-save middleware)
    const family = new Family({
      familyName,
      description,
      createdBy: req.user._id,
      admins: {
        admin1: {
          userId: req.user._id,
          assignedAt: new Date()
        }
      }
    });

    await family.save();

    // Update user's primary family
    req.user.primaryFamily = {
      familyId: family._id,
      role: 'creator',
      joinedAt: new Date(),
      status: 'active'
    };
    req.user.userType = 'family_creator';
    await req.user.save();

    // Populate family data for response
    await family.populate('createdBy', 'name email profilePicture');

    res.status(201).json({
      success: true,
      message: 'Family created successfully',
      family: {
        _id: family._id,
        familyName: family.familyName,
        familyId: family.familyId,
        description: family.description,
        createdBy: family.createdBy,
        createdAt: family.createdAt,
        memberCount: family.stats?.totalMembers || 1,
        familyUrl: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/join/${family.familyId}`,
        stats: family.stats
      }
    });

  } catch (error) {
    console.error('❌ Create family error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create family',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   GET /api/families/public/:familyId
// @desc    Get public family info for joining (no auth required for invitation links)
// @access  Public
router.get('/public/:familyId', async (req, res) => {
  try {
    const { familyId } = req.params;
    
    const family = await Family.findOne({ 
      familyId: familyId.toLowerCase(),
      isActive: true,
      isDeleted: false 
    })
    .select('familyName familyId description stats allowPublicView createdAt')
    .populate('createdBy', 'name');

    if (!family) {
      return res.status(404).json({
        success: false,
        message: 'Family not found or invitation link is invalid'
      });
    }

    res.json({
      success: true,
      family: {
        _id: family._id,
        familyName: family.familyName,
        familyId: family.familyId,
        description: family.description,
        createdBy: family.createdBy,
        createdAt: family.createdAt,
        stats: family.stats
      }
    });

  } catch (error) {
    console.error('❌ Get public family error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch family information'
    });
  }
});

// @route   POST /api/families/:familyId/join
// @desc    Join a family via invitation link
// @access  Private
router.post('/:familyId/join', authenticateToken, async (req, res) => {
  try {
    const { familyId } = req.params;
    
    // Check if user already has a family
    if (req.user.primaryFamily && req.user.primaryFamily.familyId) {
      return res.status(400).json({
        success: false,
        message: 'You are already part of a family. Each user can only belong to one family tree.'
      });
    }

    const family = await Family.findById(familyId);
    if (!family || !family.isActive || family.isDeleted) {
      return res.status(404).json({
        success: false,
        message: 'Family not found'
      });
    }

    // Update user's primary family
    req.user.primaryFamily = {
      familyId: family._id,
      role: 'member',
      joinedAt: new Date(),
      status: 'active'
    };
    await req.user.save();

    // Update family stats
    await family.updateStats();

    res.json({
      success: true,
      message: `Successfully joined ${family.familyName}`,
      family: {
        _id: family._id,
        familyName: family.familyName,
        familyId: family.familyId,
        description: family.description
      }
    });

  } catch (error) {
    console.error('❌ Join family error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to join family'
    });
  }
});

// @route   GET /api/families/:familyId
// @desc    Get specific family details (for family members)
// @access  Private
// NOTE: Single source of truth for GET /:familyId is defined below with requireFamilyAccess.

// @route   GET /api/families
// @desc    Get user's families
// @access  Private
router.get('/', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user._id)
      .populate({
        path: 'familyMemberships.familyId',
        select: 'familyName familyId description createdBy stats isPrivate createdAt',
        populate: {
          path: 'createdBy',
          select: 'name email profilePicture'
        }
      });

    const families = user.familyMemberships
      .filter(membership => membership.status === 'active' && membership.familyId)
      .map(membership => ({
        id: membership.familyId._id,
        familyName: membership.familyId.familyName,
        familyId: membership.familyId.familyId,
        description: membership.familyId.description,
        createdBy: membership.familyId.createdBy,
        createdAt: membership.familyId.createdAt,
        memberCount: membership.familyId.stats.totalMembers,
        adminCount: (membership.familyId.admins.admin1?.userId ? 1 : 0) + 
                   (membership.familyId.admins.admin2?.userId ? 1 : 0) + 
                   (membership.familyId.admins.admin3?.userId ? 1 : 0),
        isPrivate: membership.familyId.isPrivate,
        userRole: membership.role,
        joinedAt: membership.joinedAt
      }));

    res.json({
      success: true,
      families,
      count: families.length
    });
  } catch (error) {
    console.error('❌ Get families error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get families'
    });
  }
});

// @route   GET /api/families/:familyId
// @desc    Get family details
// @access  Private (Family Member)
router.get('/:familyId', authenticateToken, requireFamilyAccess, async (req, res) => {
  try {
    const { familyId } = req.params;

    // Note: admins is a nested object (admin1/admin2/admin3). Populate each subpath explicitly.
    const family = await Family.findById(familyId)
      .populate('createdBy', 'name email profilePicture')
      .populate('admins.admin1.userId', 'name email profilePicture')
      .populate('admins.admin2.userId', 'name email profilePicture')
      .populate('admins.admin3.userId', 'name email profilePicture')
      .populate('accessSettings.allowedViewers.userId', 'name email profilePicture')
      .select('-__v');

    if (!family) {
      return res.status(404).json({
        success: false,
        message: 'Family not found'
      });
    }

    res.json({
      success: true,
      family: {
        id: family._id,
        familyName: family.familyName,
        familyId: family.familyId,
        description: family.description,
        createdBy: family.createdBy,
        createdAt: family.createdAt,
        updatedAt: family.updatedAt,
        admins: family.admins,
        stats: family.stats,
        isPrivate: family.isPrivate,
        settings: family.settings,
        customFields: family.customFields,
        accessSettings: family.accessSettings,
        userRole: req.userFamilyRole
      }
    });
  } catch (error) {
    console.error('❌ Get family details error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get family details'
    });
  }
});

// @route   PUT /api/families/:familyId
// @desc    Update family details
// @access  Private (Family Admin)
router.put('/:familyId', authenticateToken, requireFamilyAdmin, async (req, res) => {
  try {
    const { familyId } = req.params;
    const { familyName, description, isPrivate, settings, customFields } = req.body;

    const family = await Family.findById(familyId);
    if (!family) {
      return res.status(404).json({
        success: false,
        message: 'Family not found'
      });
    }

    // Update fields
    if (familyName) family.familyName = familyName;
    if (description !== undefined) family.description = description;
    if (isPrivate !== undefined) family.isPrivate = isPrivate;
    if (settings) family.settings = { ...family.settings, ...settings };
    if (customFields) family.customFields = customFields;

    family.updatedAt = new Date();
    await family.save();

    res.json({
      success: true,
      message: 'Family updated successfully',
      family: {
        id: family._id,
        familyName: family.familyName,
        description: family.description,
        isPrivate: family.isPrivate,
        settings: family.settings,
        customFields: family.customFields,
        updatedAt: family.updatedAt
      }
    });
  } catch (error) {
    console.error('❌ Update family error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update family'
    });
  }
});

// @route   DELETE /api/families/:familyId
// @desc    Delete family (soft delete)
// @access  Private (Admin1 only)
router.delete('/:familyId', authenticateToken, async (req, res) => {
  try {
    const { familyId } = req.params;

    const family = await Family.findById(familyId);
    if (!family) {
      return res.status(404).json({
        success: false,
        message: 'Family not found'
      });
    }

    // Only admin1 can delete family
    const admin1 = family.admins.find(admin => admin.role === 'admin1');
    if (!admin1 || admin1.userId.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        success: false,
        message: 'Only the family creator (admin1) can delete the family'
      });
    }

    // Soft delete
    family.isActive = false;
    family.updatedAt = new Date();
    await family.save();

    // Remove family memberships from all users
    await User.updateMany(
      { 'familyMemberships.familyId': familyId },
      { $pull: { familyMemberships: { familyId } } }
    );

    res.json({
      success: true,
      message: 'Family deleted successfully'
    });
  } catch (error) {
    console.error('❌ Delete family error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete family'
    });
  }
});

// @route   POST /api/families/:familyId/admins
// @desc    Add family admin
// @access  Private (Admin1 and Admin2 only)
router.post('/:familyId/admins', authenticateToken, async (req, res) => {
  try {
    const { familyId } = req.params;
  let { email, role } = req.body;
  if (email && typeof email === 'string') email = email.toLowerCase().trim();

    if (!email || !role) {
      return res.status(400).json({
        success: false,
        message: 'Email and role are required'
      });
    }

    if (!['admin2', 'admin3'].includes(role)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid role. Must be admin2 or admin3'
      });
    }

    const family = await Family.findById(familyId);
    if (!family) {
      return res.status(404).json({
        success: false,
        message: 'Family not found'
      });
    }

    // Only admin1 can add admin2/admin3 per requirements
    const currentLevel = family.getAdminLevel(req.user._id);
    if (currentLevel !== 'admin1') {
      return res.status(403).json({ success: false, message: 'Only admin1 can assign admin roles' });
    }

    // Find user by email
  const userToAdd = await User.findOne({ email, isActive: true });
    if (!userToAdd) {
      return res.status(404).json({
        success: false,
        message: 'User not found or inactive'
      });
    }

    // Assign admin using model method (handles duplicates)
    try {
      await family.addAdmin(role, userToAdd._id, req.user._id);
    } catch (e) {
      return res.status(400).json({ success: false, message: e.message });
    }

    // Add family membership to user if not exists
    // No change to user's primary family role enum (creator/member/viewer). Admin roles are tracked on Family.admins.

    res.json({
      success: true,
      message: `${role} added successfully`,
      admin: { userId: userToAdd._id, name: userToAdd.name, email: userToAdd.email, profilePicture: userToAdd.profilePicture, role }
    });
  } catch (error) {
    console.error('❌ Add admin error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add admin'
    });
  }
});

// @route   DELETE /api/families/:familyId/admins/:role
// @desc    Remove admin2/admin3 assignment
// @access  Private (Admin1 only)
router.delete('/:familyId/admins/:role', authenticateToken, async (req, res) => {
  try {
    const { familyId, role } = req.params;

    if (!['admin2', 'admin3'].includes(role)) {
      return res.status(400).json({ success: false, message: 'Invalid role. Must be admin2 or admin3' });
    }

    const family = await Family.findById(familyId);
    if (!family) return res.status(404).json({ success: false, message: 'Family not found' });

    // Only admin1 can remove admin2/admin3
    const currentLevel = family.getAdminLevel(req.user._id);
    if (currentLevel !== 'admin1') {
      return res.status(403).json({ success: false, message: 'Only admin1 can remove admin roles' });
    }

    // If already empty, no-op
    if (!family.admins?.[role]?.userId) {
      return res.json({ success: true, message: `${role} already empty` });
    }

    await family.removeAdmin(role);

    return res.json({ success: true, message: `${role} removed successfully` });
  } catch (error) {
    console.error('❌ Remove admin error:', error);
    res.status(500).json({ success: false, message: 'Failed to remove admin' });
  }
});

// @route   GET /api/families/:familyId/members
// @desc    Get family members
// @access  Private (Family Member)
router.get('/:familyId/members', authenticateToken, requireFamilyAccess, async (req, res) => {
  try {
    const { familyId } = req.params;
    const { page = 1, limit = 50, search = '' } = req.query;

    const query = { familyId, isActive: true };
    
    if (search) {
      query.$or = [
        { firstName: { $regex: search, $options: 'i' } },
        { lastName: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } }
      ];
    }

    const members = await FamilyMember.find(query)
      .sort({ firstName: 1, lastName: 1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .select('-__v');

    const total = await FamilyMember.countDocuments(query);

    res.json({
      success: true,
      members,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalMembers: total,
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    });
  } catch (error) {
    console.error('❌ Get family members error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get family members'
    });
  }
});

// Add approved viewer
// @route   POST /api/families/:familyId/viewers
// @desc    Approve a viewer (read-only) by email
// @access  Private (Admin1/Admin2/Admin3)
router.post('/:familyId/viewers', authenticateToken, async (req, res) => {
  try {
    const { familyId } = req.params;
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ success: false, message: 'Email is required' });
     }

    const family = await Family.findById(familyId);
    if (!family) return res.status(404).json({ success: false, message: 'Family not found' });

    if (!family.isAdmin(req.user._id)) {
      return res.status(403).json({ success: false, message: 'Admin access required' });
    }

    const user = await User.findOne({ email: email.toLowerCase(), isActive: true });
    if (!user) return res.status(404).json({ success: false, message: 'User not found' });

    const already = family.accessSettings?.allowedViewers?.some(v => v.userId?.toString() === user._id.toString());
    if (already) return res.status(200).json({ success: true, message: 'Viewer already approved' });

    family.accessSettings = family.accessSettings || {};
    family.accessSettings.allowedViewers = family.accessSettings.allowedViewers || [];
    family.accessSettings.allowedViewers.push({ userId: user._id, addedBy: req.user._id, addedAt: new Date() });
    await family.save();

    return res.json({ success: true, message: 'Viewer approved successfully' });
  } catch (error) {
    console.error('❌ Approve viewer error:', error);
    res.status(500).json({ success: false, message: 'Failed to approve viewer' });
  }
});

module.exports = router;